[{"content":"Проблема На досуге ради интереса и большого потенциала, решил прошить свой роутер на открытую прошивку OpenWrt. Прошиться было очень просто - в админке роутера, в разделе Firmware просто выбрать бинарник с прошивкой, и дождаться загрузки роутера. После наката OpenWrt с досадой обнаружил, что для подключения к интернету на моем провайдере используется VPN-протокол L2TP. Однако в прошивке OpenWrt для роутера Archer C6 по-умолчанию не были предустановлены пакеты для работы по этому протоколу. Для того, чтобы установить их, нужен интернет, а чтобы подключиться к интернету нужен L2TP. Замкнутый круг. Помимо установки зависимостей из репозиториев есть возможность установить все пакеты вручную с помощью ssh, scp, но мне показалось это муторным, и я просто решил вернуть старую прошивку.\nДля начала, я попробовал сделать также, как и при прошивке OpenWrt - через веб интерфейс выбрать файл и прошиться на сток. Несмотря на то, что админка предоставила такую возможность, роутер после сего действа просто умер. После загрузки загорался индикатор питания, но ничего не происходило.\nЧто же, я знал на что иду, но попытка не пытка. Так я пришел к необходимости восстановления роутера посредством TFTP-сервера из recovery mode\u0026rsquo;a TPLink Archer C6.\nНиже приведу пошаговую инструкцию по настройке TFTP-сервера и прошивки роутера.\nTFTP? До того как встретился с необходимостью прошивки роутера я ничего не знал про этот протокол, в том числе и про его существование. Но пришлось познакомиться.\nTFTP (Trivial File Transfer Protocol) - как видно из названия это элементарнейший протокол обмена файлами. Из интересных команд у него всего get - получить файл и put - отправить файл. Однако из-за своего минимализма и простоты реализации он идеально подходит для встраиваемых систем с ограниченым объемом памяти.\nРешение Что будем делать Для восстановления роутера с помощью recovery mode\u0026rsquo;a необходимо предоставить возможность роутеру в recovery mode загрузить файл прошивки с tftp-сервера. tftp-сервер должен находиться на определенном IP и порту. Итого, если кратко:\nна ПК вручную прописать адрес 192.168.0.66 (ip по которому ходит роутер на tftp-сервер) подключить роутер к ПК по ethernet кабелю установить и запустить tftp сервер на порту 69 дождаться пока роутер сам себя прошьет Пререквизиты Я использую Manjaro Linux с KDE, однако с небольшими изменениями инструкция должна подходить для любого дистрибутива Linux, и скорее всего MacOS. Итого, что нужно:\nПК/Ноут на (Arch-based) Linux пачкорд роутер терпение Установка и настройка TFTP-сервера В качестве реализации сервера я выбрал tftp-hpa как рекомендует ArchWiki.\nУстановить tftp-сервер sudo pacman -S tftp-hpa Скорректировать конфиг tftp-hpa по пути /etc/conf.d/tftpd, чтобы он содержал следующее: TFTPD_ARGS=\u0026#34;--secure /srv/tftp/ --create --verbosity 5 --address 0.0.0.0:69 --username=tftp\u0026#34; где:\n/srv/tftp/ путь то директории где будет лежать наша прошивка --create - запустить сервер с возможностью создавать файлы --verbosity 5 - писать DEBUG логи в syslog --adress - хост и порт на котором будет запущен сервер. Порт ставим по-умолчанию - 69 Запустить systemd демон tftp-сервера: sudo systemctl start tftpd Чтобы не заморачиваться с пользователями, правами, группами \u0026ndash; разрешить полный доступ к директории /srv/tftp/ sudo chmod -R 777 /srv/tftp Загрузить прошивкув соответствии с ревизией из поста https://4pda.to/forum/index.php?showtopic=976692\u0026view=findpost\u0026p=121017717 Для начала попробуйте самую старую, для ревизии 2, например, это Archer C6(RU)_V2_20190115.zip. Если не получилось - поочередно поднимайте версию до тех пор, пока не получится. Мне потребовалось 2 попытки, таким образом, рабочим образом для моего роутера была Archer C6(RU)_V2_200508.zip Проверить, что сервер может отдавать файлы Пункт необходим из-за очень скудных логов сервера tftp. запустить tftp клиент tftp после успешного подключения появится приглашение командной строки. Выполнить команду загрузки файла ниже, и нажать enter: get ArcherC6v2_tp_recovery.bin в случае успеха вы не получите никакого соощбения, но в директории в которой была запущена команда появится наш файл ArcherC6v2_tp_recovery.bin если произошла ошибка permission denied, выполнить sudo chmod 777 ArcherC6v2_tp_recovery.bin повторно выполнить команду get ArcherC6v2_tp_recovery.bin если появилась ошибка file not found, то либо вы забыли исправить конфиг (см п.2), либо выполняете на отличном от arch-based дистрибутиве (конфиг должен лежать в другом месте) Настройка проводного подключения Как было упомянуто выше, необходимо сделать так, чтобы TFTP-сервер был в сети роутера по определенному IP и на определенном порту. Для этого настроим проводное подключение.\nПодключить включенный роутер к ПК с помощью ethernet кабеля. В роутер воткнуть в любой порт КРОМЕ WAN. Если в настройках сети у вас отсутствует проводное соединение, по после подключения оно должно автоматически создасться. Желательно, чтобы на момент прошивки к ПК был подключен только один ethernet кабель для предупреждения возможных коллизий.\nОткрыть настройки проводного соединения (которое отвечает за подключение к роутеру). Я использую KDE, скриншоты будут оттуда. Выполнить следующие настройки:\nна вкладке Wired установить значение поля Link negotiation в Automatic на кладке ipv4: Method: Manual Нажать кнопку добавить в таблице. Добавить адресс 192.168.0.66, маска 255.255.255.0 Сохранить. Подключиться.\nЕсли всё сделано правильно, то соединение должно пройти корректно.\nСкриншоты Прошивка Для того, чтобы мы могли понять, пробует ли роутер подключиться к TFTP-серверу, необходимо подключиться к DEBUG логам TFTP-сервера с помощью journalctl. Как смотреть DEBUG логи по отдельному юниту я разбираться не стал, поэтому просто подключимся к стриму и будем ждать сообщений помеченных как in.tftpd. Для этого в терминале выполнить:\nsudo journalctl -f И прошиваем.\nВыключить роутер. Соединение пропадет. В окне с логами будет много логов от network manager\u0026rsquo;a. Зажать кнопку reset на роутере, одновременно включить роутер. Держать reset до тех пор, пока не загорится индикатор замка. Наблюдать за логами journalctl. Если все сделано правильно, должно появиться сообщение вроде такого: дек 31 20:17:20 username-pc in.tftpd[14732]: *RRQ from 192.168.0.86 filename ArcherC6v2_tp_recovery.bin* Если сообщение появилось - радуйтесь. Роутер перезагрузится. Не трогайте его 5-7 минут. Если по прошествии этого времени остался гореть только самый левый индикатор, выберите другую версию прошивки и повторите п11.\n","date":"2024-01-01T00:00:00Z","permalink":"https://ingvarlistard.github.io/p/tftp-server-example/","title":"TFTP-сервер напримере прошивки TPLink Archer C6"},{"content":"Проблема YouTube\u0026rsquo;ом пользуются все. Кто-то для развлечения, кто-то для обучения. Лично я провожу в нем часы ежедневно: просмотр MOOC курсов, научно-популярных докладов, интервью, прослушивание каких-либо видео в фоне или во время еды.\nОднако в последнее моя поисковая и рекомендательная выдача сильно упала в качестве. Мне прилетает большое количество рекомендаций уже просмотренных или частично просмотренных видео, видео с одних и тех же каналов. Такое ощущение, что я оказался в изоляции внутри пузыря своих подписок.\nТакже раздражает назойливые рекламные интеграции, которые зачастую разрывают повествование и снижают концентрацию. Раздражают постоянно появляющиеся одни и те же \u0026ldquo;миксы\u0026rdquo;, надоедливые shorts\u0026rsquo;ы. В поисковой выдачи после 5 релевантных видео появляются видео из рекомендаций, что жутко бесит.\nВ итоге, чаша переполнилась, я расчехлил гугл, и ниже опишу, чего интересного я там нашел.\nРешение Я использую Chrome-based браузер и android смартфон. Решения для firefox будут аналогичными, а вот решения для IOS придется искать самостоятельно.\nБлокировка рекламы Для браузера достаточно поставить следующие расширения:\nuBlock Origin - если еще не стоит. Режет нативную рекламу YouTube SponsorBlock - автоматический пропуск назойливых интеграций, самореклам и тому подобных вещей. Имеет огромное количество настроек. На Android же рекомендую поставить приложение YouTube ReVanced:\nYouTube ReVanced 4pda По сути оригинальное приложение YouTube с вырезанной рекламой, в том числе и спонсорской. Улучшение выдачи Для удаления Shorts\u0026rsquo;ов и Mix\u0026rsquo;ов ставим расширение Unhook:\nUnhook - Remove YouTube Recommended Videos Ставим соответствующие галки: Скрин Для улучшения качества рекомендаций нужно явно дать понять YouTube\u0026rsquo;у какие видео вам не нравятся. На это уйдет какое-то количество времени. У меня процесс занял порядка двух-трех дней. Для этого на странице рекомендаций на не понравившихся видео нужно нажать меню \u0026ldquo;Три точки\u0026rdquo; -\u0026gt; Не интересует -\u0026gt; Расскажите почему, и, собственно, расскажите. Скрины Для скрытия просмотренных видео необходимо:\nУстановить расширение Tampermonkey Установить user-script YouTube: Hide Watched Videos В итоге должно получиться как-то так Скрин Чтобы поисковая выдача в YouTube не отвлекала вас рекомендациями, а релевантность была на высоте, достаточно перестать пользоваться поиском видео в YouTube, а использовать поиск Google и Яндекс, добавив к поисковому запросу ~site:youtube.com~. Ходят слухи, что выдача в Яндексе даже лучше. Пример запроса:\nСкрин Кардинальные методы Если вы обучаетесь по роликам из YouTube\u0026rsquo;a и не хотите отвлекаться на котиков во время обучения, а пользоваться рекомендациями YouTube все еще хотите, то заведите отдельный аккаунт для обучения, в котором будете просматривать только соответствующий контент. Через какое-то время алгоритмы YouTube обучатся на ваших просмотрах, и будет подсовывать релевантную выдачу. Для удобного использования сразу нескольких аккаунтов в Firefox есть прекрасное расширение Firefox Multi-Account Containers, которое позволяет создавать изолированный контекст серфинга, и в одном окне браузера заходить в n-е число аккаунтов на одном ресурсе. Полноценных альтернатив для Chrome-based браузера я не нашел, но есть аналог MultiLogin.\nЕсли вы переживаете, что YouTube следит за вами, и вас беспокоит этот факт, то есть альтернативные свободные (Open-source) клиенты YouTube как для веба, так и для Android\nNewPipe - альтернативный, свободный клиент для Android. Позволяет просматривать видео, формировать плейлисты и подписки без рекламы и наличия YouTube-аккаунта. Доступен в Google Play и F-Droid. Piped (GitHub) - альтернативный веб клиент YouTube. Позволяет делать всё тоже, что и NewPipe. Не следит за вами, выдает качественные результаты поиска без примеси рекомендаций. Быстр и удобен. Однако для безопасного и надежного использования крайне рекомендуется развернуть собственный инстанс клиента. ","date":"2023-12-26T00:00:00Z","permalink":"https://ingvarlistard.github.io/p/youtube-tricks/","title":"YouTube Tricks - Как пользоваться YouTube с минимумом потерь"},{"content":"Предисловие Nuxt — \u0026ldquo;фреймворк над фреймворком Vue\u0026rdquo; или популярная конфигурация Vue-based приложений с использованием лучших практик разработки на Vue. Среди них: организация каталогов приложения; включение и преконфигурация самых популярных инструментов в виде Nuxt модулей; включение Vuex по-умолчанию в любую конфигурацию; готовый и преднастроенный SSR с hot-reloading\u0026rsquo;ом\nDjango — самый популярный веб-фреймворк на почти самом популярном языке программирования на сегодняшний день — Python. Сами разработчики позиционируют проект как \u0026ldquo;Веб-фреймворк для перфекционистов с дедлайнами\u0026rdquo;. Представляет из себя решение \u0026ldquo;всё в одном\u0026rdquo; и позволяет в кратчайшие сроки построить MVP вашего веб-приложения.\nGraphQL — язык запросов изначально созданный компанией Facebook. В статье будет говориться о конкретных реализациях протокола этого языка, а именно библиотек Apollo для фронтенда и graphene для бэкенда.\nО чем и для кого эта статья В этой статье вы сможете узнать как можно собрать dev-окружение современного SPA приложения с server side рендерингом, на основе фреймворков Django и Nuxt, а также их сообщения посредством GraphQL API.\nНа примере простейшего приложения со списком задач, я попытался рассказать об основных проблемах с которыми я столкнулся в процессе построения приложения на выбранном стеке.\nОписание старался делать как можно более понятным, в том числе и новичкам в программировании (коим, буду честен, я считаю и себя), и приводить как можно больше ссылок.\nИсходя из того, что эту статью вы читаете на русском языке, я делаю смелое предположение, что и остальные материалы по программированию вы также предпочитаете читать на русском, поэтому все ссылки я старался подбирать в соответствии с этим предположением насколько это возможно.\nИскрене надеюсь, что статья поможет сэкономить хоть немного времени тем энтузиастам, кто решит создать свое приложения на базе приведенных выше технологий, а также дать быстрый старт всем интересующимся без необходимости проводить часы и дни в поисках причин возникающих проблем, а затем и их решений на просторах интернета.\nПостроение приложения будет вестись поэтапно, чтобы на каждом этапе можно было удостовериться что всё работает правильно.\nПеред началом Убедитесь, что у вас уже установлен node.js и интерпретатор python. В примере используются версии: 13.9 и 3.7 соответственно.\nВ качестве менеджера виртуального окружения python в статье будет использоваться pipenv.\nКонсольные команды в статье запускаются в оболочке bash. Если вы пользователь Windows, то вместо команд cd, mv, mkdir используйте аналоги, и благодаря кросс-платформенной природе python и node, всё остальное должно работать вне зависимости от ОС.\nВ качестве базы данных для простоты будет использоваться Sqlite, которая не требует дополнительной конфигурации.\nВерсии всех пакетов вы всегда можете посмотреть в репозитории статьи. Ниже я приведу те, что мы будем устанавливать вручную.\nPython библиотеки\nБиблиотека Версия django 2.2 graphene-django 2.8.2 django-cors-headers 3.2 Javascript библиотеки\nБиблиотека Версия Nuxt 2.11 nuxtjs/apollo 4.0.1 nuxtjs/vuetify 0.5.5 cookie-universal-nuxt 2.1.2 graphql-tag 2.10 Django Создание проекта и окружения Для начала необходимо установить менеджер виртуального окружения. В примере я буду использовать pipenv. Для установки:\npip install pipenv В некоторых операционных системах для этого действия могут потребоваться права суперпользователя. Также pipenv можно установить из репозитория вашей операционной системы.\nСоздадим директорию с проектом и инициализируем в ней окружение pipenv. В моем случае проект будет располагаться по пути ~/Documents/projects/todo-list. Создадим эту директорию и перейдем в неё.\nmkdir ~/Documents/projects/todo-list cd ~/Documents/projects/todo-list Создаем виртуальное окружение и одновременно устанавливаем django и graphene_django:\npipenv install django==2.2.10 graphene_django Библиотека graphene_django позволяет описывать схему GraphQL API на основе моделей Django ORM. Очень удобно, но как по мне, со связыванием таблиц БД и фронтом напрямую нужно быть очень осторожным.\nДля начала активируем виртуальное окружение pipenv. Далее в статье будет предполагаться, что все комманды будут выполняться внутри окружения.\npipenv shell # активируем виртуальное окружение pipenv Создаем проект Django.\ndjango-admin createapp backend Настройка Перенос manage.py Так как фронтенд и бэкенд нашего todo-листа будет находиться в одной директории, было бы неплохо иметь все управляющие файлы в корневой директории проекта. В Django управляющим файлом является manage.py, давайте вынесем его из директории backend на уровень повыше.\nДля этого, из корневой директории проекта:\nmv backend/manage.py . После перемещения нужно исправить путь к файлу настроек внутри файла manage.py.\n# manage.py import os import sys if __name__ == \u0026#34;__main__\u0026#34;: # укажите путь к файлу настроек вашего проекта os.environ.setdefault(\u0026#34;DJANGO_SETTINGS_MODULE\u0026#34;, \u0026#34;backend.backend.settings\u0026#34;) ... Также в файле backend/backend/settings.py приведем следующие переменные к виду:\nROOT_URLCONF = \u0026#39;backend.backend.urls\u0026#39; WSGI_APPLICATION = \u0026#39;backend.backend.wsgi.application\u0026#39; Добавление graphene_django В файле backend/backend/settings.py в переменную INSTALLED_APPS добавляем установленный ранее graphene_django:\n# backend/backend/settings.py INSTALLED_APPS = [ ..., \u0026#39;graphene_django\u0026#39;, ] Проверяем работоспособность python manage.py runserver По-умолчанию сервер запускается на порту 8000. Переходим на http://localhost:8000/, он должен нас встречать следующей картиной:\nDjango hello Django hello Настройка graphene После изменений ниже http://localhost:8000/ уже не будет встречать нас ракетой. В файле backend/backend/urls.py\n# backend/backend/urls.py from django.contrib import admin from django.urls import path from graphene_django.views import GraphQLView from django.conf import settings urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), # graphiql - мини IDE для разработки graphql запросов path(\u0026#39;graphql/\u0026#39;, GraphQLView.as_view(graphiql=settings.DEBUG)) ] Создадим пустую схему, например, в файле backend/backend/api.py\n# backend/todo_list/api.py import graphene schema = graphene.Schema() В файл настроек необходимо добавить переменную GRAPHENE, в которой мы укажем путь до нашей схемы:\n# /backend/backend/settings.py GRAPHENE = { \u0026#39;SCHEMA\u0026#39;: \u0026#39;backend.backend.api.schema\u0026#39;, } Проверяем работоспособность. Запускаем сервер уже известной командой runserver:\npython manage.py runserver и переходим на http://localhost:8000/graphql/. Там нас должна встретить та самая мини \u0026ldquo;IDE\u0026rdquo; GrapiQL:\nGraphiql IDE Graphiql ide Ничего страшного в том, что нас встречает ошибка. Она появляется из-за того, что наша схема пуста. Мы исправим это при реализации дальше.\nПриложение todo_list Создание приложения Создадим приложение todo_list и модели к нему. Не забывайте, что все команды должны выполняться внутри окружения pipenv:\ncd backend django-admin startapp todo_list Скрипт django-admin не знает где находится корень нашего приложения, поэтому нам нужно немного подправить файл backend/todo_list/apps.py, чтобы он выглядит следующим образом:\nfrom django.apps import AppConfig class TodoListConfig(AppConfig): name = \u0026#39;backend.todo_list\u0026#39; Добавим наше новое приложение в INSTALLED_APPS, что находится в файле settings.py:\n# backend/backend/settings.py INSTALLED_APPS = [ ..., \u0026#39;backend.todo_list\u0026#39;, ... ] Добавим модели Todo и Category в файл backend/todo_list/models.py:\nmodels.py # backend/todo_list/models.py from datetime import timedelta from django.db import models from django.utils import timezone class Category(models.Model): name = models.CharField(max_length=100, unique=True) class Meta: verbose_name = \u0026#39;Категория\u0026#39; verbose_name_plural = \u0026#39;Категории\u0026#39; def __str__(self): return self.name def get_due_date(): \u0026#34;\u0026#34;\u0026#34; На выполнение задачи по-умолчанию даётся один день \u0026#34;\u0026#34;\u0026#34; return timezone.now() + timedelta(days=1) class Todo(models.Model): title = models.CharField(max_length=250) text = models.TextField(blank=True) created_date = models.DateField(auto_now_add=True) due_date = models.DateField(default=get_due_date) category = models.ForeignKey(Category, related_name=\u0026#39;todo_list\u0026#39;, on_delete=models.PROTECT) done = models.BooleanField(default=False) class Meta: verbose_name = \u0026#39;Задача\u0026#39; verbose_name_plural = \u0026#39;Задачи\u0026#39; def __str__(self): return self.title Для того, чтобы наши модели превратились в таблицы в БД, нужно выполнить следующее:\nСоздать файлы миграций, в которых будет описываться наша текущая схема:\npython manage.py makemigrations С примерно таким выводом:\nВывод Применить эти миграции командой migrate. Т.к. это первый запуск скрипта migrate, у нас также будут применяться миграции приложений Django:\npython manage.py migrate Вывод консоли Вывод консоли Создание GraphQL API Опишем типы, создадим запросы и мутации для наших новых моделей. Для этого в директории приложения todo_list создадим файл schema.py, со следующим содержимым:\nschema.py # backend/todo_list/schema.py import graphene from graphene_django import DjangoObjectType from backend.todo_list.models import Todo, Category # С помощью graphene_django привязываем типы к моделям, # что позволит ходить по всей вложенности базы данных как угодно, # прямо из интерфейса GraphiQL. # Однако будьте осторожны, связывание таблиц практически напрямую # с фронтом может быть чревато при росте проекта. Думаю такой способ # подходит преимущественно для небольших CRUD приложений. class CategoryNode(DjangoObjectType): class Meta: model = Category class TodoNode(DjangoObjectType): class Meta: model = Todo class Query(graphene.ObjectType): \u0026#34;\u0026#34;\u0026#34; Описываем запросы и возвращаемые типы данных \u0026#34;\u0026#34;\u0026#34; todo_list = graphene.List(TodoNode) categories = graphene.List(CategoryNode) def resolve_todo_list(self, info): return Todo.objects.all().order_by(\u0026#39;-id\u0026#39;) def resolve_categories(self, info): return Category.objects.all() class Mutation(graphene.ObjectType): \u0026#34;\u0026#34;\u0026#34; В мутации описываем типы запросов (простите за каламбур), типы возвращаемых данных и типы принимаемых переменных \u0026#34;\u0026#34;\u0026#34; add_todo = graphene.Field(TodoNode, title=graphene.String(required=True), text=graphene.String(), due_date=graphene.Date(required=True), category=graphene.String(required=True)) remove_todo = graphene.Field(graphene.Boolean, todo_id=graphene.ID()) toggle_todo = graphene.Field(TodoNode, todo_id=graphene.ID()) def resolve_add_todo(self, info, **kwargs): category, _ = Category.objects.get_or_create(name=kwargs.pop(\u0026#39;category\u0026#39;)) return Todo.objects.create(category=category, **kwargs) def resolve_remove_todo(self, info, todo_id): try: Todo.objects.get(id=todo_id).delete() except Todo.DoesNotExist: return False return True def resolve_toggle_todo(self, info, todo_id): todo = Todo.objects.get(id=todo_id) todo.done = not todo.done todo.save() return todo После создания классов мутации и запроса, их нужно добавить в нашу схему. Как вы, возможно, помните схему мы описывали в файле api.py:\n# backend/backend/api.py import graphene from backend.todo_list.schema import Query, Mutation schema = graphene.Schema(query=Query, mutation=Mutation) Если хотите лучше понять происходящее, можете прочитать эту статью на Хабре, или обратиться к документации Graphene (англ.).\nПроверка API ID записей в примерах ниже могут различаться с ID ваших записей.\nЗапускаем сервер привычной командой runserver:\npython manage.py runserver Идем по пути http://localhost:8000/graphql/. Там нас должен встречать уже знакомый интерфейс graphiql. И как вы, возможно, заметили ошибка пропала.\nДавайте проверим получившиеся запросы и мутации.\naddTodo Мутация\nmutation( $title: String! $text: String $dueDate: Date! $category: String! ) { addTodo( title: $title text: $text dueDate: $dueDate category: $category ) { todo { id title text done createdDate dueDate category { id name } } } } Переменные\n{ \u0026#34;title\u0026#34;: \u0026#34;First Todo\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Just do it!\u0026#34;, \u0026#34;dueDate\u0026#34;: \u0026#34;2020-10-17\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Работа\u0026#34; } Результат\nРезультат В результате этой мутации у нас создалось две записи:\nTodo т.к. собственно мутация для этого и написана; Category, т.к. в базе не оказалось категорий с названием \u0026ldquo;Работа\u0026rdquo;, а метод get_or_create говорит за себя сам. todoList и categories Запрос\n{ todoList { id title text createdDate dueDate category { id name } } categories { id name } } Реузльтат\nРезультат toggleTodo Мутация\nmutation ($todoId: ID) { toggleTodo(todoId: $todoId) { id title text createdDate dueDate category { id name } done } } Переменные\n{ \u0026#34;todoId\u0026#34;: \u0026#34;1\u0026#34; } Результат:\nРезультат removeTodo Мутация\nmutation ($todoId: ID) { removeTodo(todoId: $todoId) } Переменные можно оставить из предыдущей мутации.\nРезультат\nРезультат Nuxt Создание Nuxt приложения Откройте консоль внутри корневой директории проекта и запустите скрипт установки Nuxt:\nnpx create-nuxt-app frontend Запустится очень простой и понятный скрипт установки, который предложит указать описание проекта и предоставит на выбор для установки несколько библиотек. Можете выбрать, что захотите, но из рекомендуемых пунктов я бы посоветовал выбрать \u0026ldquo;Custom UI Framework: vuetify\u0026rdquo;, т.к. в примере используется именно он, и \u0026ldquo;Rendering mode: Universal\u0026rdquo;, т.к. в статье рассматривается пример именно с SSR.\nПример моей конфигурации:\nНа установку зависимостей может потребоваться некоторое время. После завершения работы скрипта вам предложат проверить его работоспособность. Давайте сделаем это:\ncd frontend npm run dev и перейдем на http://localhost:3000. Там нас должна ждать страница приветствия Nuxt + Vuetify:\nNuxt + Vuetify Nuxt + Vuetify Перенос конфигурационных файлов Как я говорил ранее, фронтенд и бэкенд будут находиться у нас в одной директории, поэтому было бы неплохо перенести конфигурационные файлы и зависимости на уровень повыше. Для этого из корневой папки проекта выполните:\ncd frontend mv node_modules .. mv nuxt.config.js .. mv .gitignore .. mv package-lock.json .. mv package.json .. mv .prettierrc .. mv .eslintrc.js .. mv .editorconfig .. rm -rf .git Затем в файле nuxt.config.js указываем корневую директорию приложения:\n// nuxt.config.js export default { ..., rootDir: \u0026#39;frontend\u0026#39;, ... } После этого желательно еще раз убедиться в работоспособности проекта, выполнив запуск dev-сервера уже из корневой директории:\nnpm run dev Верстка функционального макета Любой компонент с префиксом v- это компонент UI-toolkit\u0026rsquo;a Vuetify. У этой библиотеки отличная и подробная документация.\nЕсли вы хотите подробнее узнать, что делает тот или иной компонент, смело вбивайте в гугл v-component-name. Только не забывайте, что в примере используется версия vuetify 1.5.\nПриводим файл frontend/layouts/default.vue к виду:\n\u0026lt;template\u0026gt; \u0026lt;v-app\u0026gt; \u0026lt;v-content\u0026gt; \u0026lt;v-container\u0026gt; \u0026lt;nuxt /\u0026gt; \u0026lt;/v-container\u0026gt; \u0026lt;/v-content\u0026gt; \u0026lt;/v-app\u0026gt; \u0026lt;/template\u0026gt; Создадим компонент нового Todo по пути frontend/components/NewTodoForm.vue:\nNewTodoForm.vue \u0026lt;!-- frontend/components/NewTodoForm.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;v-form ref=\u0026#34;form\u0026#34; v-model=\u0026#34;valid\u0026#34;\u0026gt; \u0026lt;v-card\u0026gt; \u0026lt;v-card-text class=\u0026#34;pt-0 mt-0\u0026#34;\u0026gt; \u0026lt;v-layout row wrap\u0026gt; \u0026lt;v-flex xs8\u0026gt; \u0026lt;!-- Поле ввода имени задачи --\u0026gt; \u0026lt;v-text-field v-model=\u0026#34;newTodo.title\u0026#34; :rules=\u0026#34;[nonEmptyField]\u0026#34; label=\u0026#34;Задача\u0026#34; prepend-icon=\u0026#34;check_circle_outline\u0026#34; /\u0026gt; \u0026lt;/v-flex\u0026gt; \u0026lt;v-flex xs4\u0026gt; \u0026lt;!-- Поле выбора даты выполнения задачи --\u0026gt; \u0026lt;v-menu ref=\u0026#34;menu\u0026#34; v-model=\u0026#34;menu\u0026#34; :close-on-content-click=\u0026#34;false\u0026#34; :nudge-right=\u0026#34;40\u0026#34; :return-value.sync=\u0026#34;newTodo.dueDate\u0026#34; lazy transition=\u0026#34;scale-transition\u0026#34; offset-y full-width min-width=\u0026#34;290px\u0026#34; \u0026gt; \u0026lt;template v-slot:activator=\u0026#34;{ on }\u0026#34;\u0026gt; \u0026lt;v-text-field v-model=\u0026#34;newTodo.dueDate\u0026#34; :rules=\u0026#34;[nonEmptyField]\u0026#34; v-on=\u0026#34;on\u0026#34; label=\u0026#34;Дата выполнения\u0026#34; prepend-icon=\u0026#34;event\u0026#34; readonly /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;v-date-picker v-model=\u0026#34;newTodo.dueDate\u0026#34; no-title scrollable locale=\u0026#34;ru-ru\u0026#34; first-day-of-week=\u0026#34;1\u0026#34; \u0026gt; \u0026lt;v-spacer /\u0026gt; \u0026lt;v-btn @click=\u0026#34;menu = false\u0026#34; flat color=\u0026#34;primary\u0026#34;\u0026gt;Отмена\u0026lt;/v-btn\u0026gt; \u0026lt;v-btn @click=\u0026#34;$refs.menu.save(newTodo.dueDate)\u0026#34; flat color=\u0026#34;primary\u0026#34; \u0026gt;Выбрать\u0026lt;/v-btn \u0026gt; \u0026lt;/v-date-picker\u0026gt; \u0026lt;/v-menu\u0026gt; \u0026lt;/v-flex\u0026gt; \u0026lt;v-flex xs12\u0026gt; \u0026lt;v-textarea v-model=\u0026#34;newTodo.text\u0026#34; :rules=\u0026#34;[nonEmptyField]\u0026#34; label=\u0026#34;Описание\u0026#34; prepend-icon=\u0026#34;description\u0026#34; hide-details rows=\u0026#34;1\u0026#34; class=\u0026#34;py-0 my-0\u0026#34; /\u0026gt; \u0026lt;/v-flex\u0026gt; \u0026lt;/v-layout\u0026gt; \u0026lt;/v-card-text\u0026gt; \u0026lt;v-card-actions\u0026gt; \u0026lt;!-- Селектор категорий. Позволяет добавлять несуществующие позиции --\u0026gt; \u0026lt;v-combobox v-model=\u0026#34;newTodo.category\u0026#34; :rules=\u0026#34;[nonEmptyField]\u0026#34; :items=\u0026#34;categories\u0026#34; hide-details label=\u0026#34;Категория\u0026#34; class=\u0026#34;my-0 mx-2 mb-2 pt-0\u0026#34; prepend-icon=\u0026#34;category\u0026#34; /\u0026gt; \u0026lt;v-spacer /\u0026gt; \u0026lt;v-btn :disabled=\u0026#34;!valid\u0026#34; @click=\u0026#34;add\u0026#34; color=\u0026#34;blue lighten-1\u0026#34; flat \u0026gt;Добавить\u0026lt;/v-btn \u0026gt; \u0026lt;/v-card-actions\u0026gt; \u0026lt;/v-card\u0026gt; \u0026lt;/v-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;NewTodoForm\u0026#39;, data() { return { newTodo: null, categories: [\u0026#39;Дом\u0026#39;, \u0026#39;Работа\u0026#39;, \u0026#39;Семья\u0026#39;, \u0026#39;Учеба\u0026#39;], valid: false, menu: false, nonEmptyField: text =\u0026gt; text ? !!text.length : \u0026#39;Поле не должно быть пустым\u0026#39; } }, created() { this.clear() }, methods: { add() { this.$emit(\u0026#39;add\u0026#39;, this.newTodo) this.clear() this.$refs.form.reset() }, clear() { this.newTodo = { title: \u0026#39;\u0026#39;, text: \u0026#39;\u0026#39;, dueDate: \u0026#39;\u0026#39;, category: \u0026#39;\u0026#39; } } } } \u0026lt;/script\u0026gt; Далее компонент существующего Todo, там же:\nTodoItem.vue \u0026lt;!-- frontend/components/TodoItem.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;v-card\u0026gt; \u0026lt;v-card-title class=\u0026#34;pb-1\u0026#34; style=\u0026#34;overflow-wrap: break-word;\u0026#34;\u0026gt; \u0026lt;b\u0026gt;{{ todo.title }}\u0026lt;/b\u0026gt; \u0026lt;v-spacer /\u0026gt; \u0026lt;v-btn @click=\u0026#34;$emit(\u0026#39;delete\u0026#39;, todo.id)\u0026#34; flat small icon style=\u0026#34;position: absolute; right: 0; top: 0\u0026#34; \u0026gt; \u0026lt;v-icon :disabled=\u0026#34;$nuxt.isServer\u0026#34; small\u0026gt;close\u0026lt;/v-icon\u0026gt; \u0026lt;/v-btn\u0026gt; \u0026lt;/v-card-title\u0026gt; \u0026lt;v-card-text class=\u0026#34;py-1\u0026#34;\u0026gt; \u0026lt;v-layout row justyfy-center align-center\u0026gt; \u0026lt;v-flex xs11 style=\u0026#34;overflow-wrap: break-word;\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/v-flex\u0026gt; \u0026lt;v-flex xs1\u0026gt; \u0026lt;div style=\u0026#34;text-align: right;\u0026#34;\u0026gt; \u0026lt;v-checkbox v-model=\u0026#34;todo.done\u0026#34; hide-details class=\u0026#34;pa-0 ma-0\u0026#34; style=\u0026#34;display: inline-block;\u0026#34; color=\u0026#34;green lighten-1\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/v-flex\u0026gt; \u0026lt;/v-layout\u0026gt; \u0026lt;/v-card-text\u0026gt; \u0026lt;v-card-actions\u0026gt; \u0026lt;span class=\u0026#34;grey--text\u0026#34;\u0026gt; Выполнить до \u0026lt;v-icon small\u0026gt;event\u0026lt;/v-icon\u0026gt; {{ todo.dueDate }} | Создано \u0026lt;v-icon small\u0026gt;calendar_today\u0026lt;/v-icon\u0026gt; {{ todo.createdDate }} \u0026lt;/span\u0026gt; \u0026lt;v-spacer /\u0026gt; \u0026lt;span class=\u0026#34;grey--text\u0026#34;\u0026gt; \u0026lt;v-icon small\u0026gt;category\u0026lt;/v-icon\u0026gt;Категория: {{ todo.category }} \u0026lt;/span\u0026gt; \u0026lt;/v-card-actions\u0026gt; \u0026lt;/v-card\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;TodoItem\u0026#39;, props: { todo: { type: Object, default: () =\u0026gt; ({}) } } } \u0026lt;/script\u0026gt; И наконец вставим новые компоненты в index.vue, и добавим в него немного рыбы:\nindex.vue \u0026lt;!-- frontend/pages/index.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;v-layout row wrap justify-center\u0026gt; \u0026lt;v-flex xs8 class=\u0026#34;pb-1\u0026#34;\u0026gt; \u0026lt;new-todo-form @add=\u0026#34;addTodo\u0026#34; /\u0026gt; \u0026lt;/v-flex\u0026gt; \u0026lt;v-flex v-for=\u0026#34;todo of todoList\u0026#34; :key=\u0026#34;todo.id\u0026#34; xs8 class=\u0026#34;my-1\u0026#34;\u0026gt; \u0026lt;todo-item :todo=\u0026#34;todo\u0026#34; @delete=\u0026#34;deleteTodo\u0026#34; /\u0026gt; \u0026lt;/v-flex\u0026gt; \u0026lt;/v-layout\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import NewTodoForm from \u0026#39;../components/NewTodoForm\u0026#39; import TodoItem from \u0026#39;../components/TodoItem\u0026#39; export default { components: { TodoItem, NewTodoForm }, data() { return { todoList: [ { id: 1, title: \u0026#39;TODO 1\u0026#39;, text: \u0026#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit\u0026#39;, dueDate: \u0026#39;2020-10-16\u0026#39;, createdDate: \u0026#39;2020-03-09\u0026#39;, done: false, category: \u0026#39;Работа\u0026#39; }, { id: 2, title: \u0026#39;TODO 2\u0026#39;, text: \u0026#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit\u0026#39;, dueDate: \u0026#39;2020-10-16\u0026#39;, createdDate: \u0026#39;2020-03-09\u0026#39;, done: false, category: \u0026#39;Работа\u0026#39; }, { id: 3, title: \u0026#39;TODO 3\u0026#39;, text: \u0026#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit\u0026#39;, dueDate: \u0026#39;2020-10-16\u0026#39;, createdDate: \u0026#39;2020-03-09\u0026#39;, done: false, category: \u0026#39;Работа\u0026#39; }, { id: 4, title: \u0026#39;TODO 4\u0026#39;, text: \u0026#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit\u0026#39;, dueDate: \u0026#39;2020-10-16\u0026#39;, createdDate: \u0026#39;2020-03-09\u0026#39;, done: false, category: \u0026#39;Работа\u0026#39; }, { id: 5, title: \u0026#39;TODO 5\u0026#39;, text: \u0026#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit\u0026#39;, dueDate: \u0026#39;2020-10-16\u0026#39;, createdDate: \u0026#39;2020-03-09\u0026#39;, done: false, category: \u0026#39;Работа\u0026#39; }, { id: 6, title: \u0026#39;TODO 6\u0026#39;, text: \u0026#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit\u0026#39;, dueDate: \u0026#39;2020-10-16\u0026#39;, createdDate: \u0026#39;2020-03-09\u0026#39;, done: false, category: \u0026#39;Работа\u0026#39; } ] } }, methods: { addTodo(newTodo) { const id = this.todoList.length ? Math.max.apply( null, this.todoList.map(item =\u0026gt; item.id) ) + 1 : 1 this.todoList.unshift({ id, createdDate: new Date().toISOString().substr(0, 10), done: false, ...newTodo }) }, deleteTodo(todoId) { this.todoList = this.todoList.filter(item =\u0026gt; item.id !== todoId) } } } \u0026lt;/script\u0026gt; После проделанной работы рекомендую проверить работоспособность получившегося макета. Запустите dev сервер и перейдите на http://localhost:3000/, там вы должны увидеть следующую картину:\nФункциональный макет Nuxt + Vuetify Объединение фронтенда и бэкенда Настройка CSRF-защиты Django + Apollo В Django по-умолчанию используется CSRF защита.\nЭта защита реализуется при помощи промежуточного слоя (middleware) — CsrfViewMiddleware. Посмотреть на него вы можете в файле settings.py в переменной MIDDLEWARE.\nПринцип его работы очень прост: у любого POST-запроса к Django в заголовках должен иметься CSRF-токен. Если этот токен отсутствует, то сервер просто отклоняет этот запрос.\nCSRF-токен в классическом django приложении приходит вместе с любым GET-запросом, после чего при необходимости добавляется в формы при рендеринге шаблона.\nВ нашем случае проблема в том, что вне зависимости от того, выполняется в Apollo мутация или запрос, метод их по-умолчанию всегда будет POST. Apollo позволяет изменить это поведение таким образом, чтобы для Query метод запроса был GET, а для Mutation — POST, но насколько я знаю, graphene на данный момент не поддерживает подобный режим работы.\nЯ поступил следующим образом: немного расширил логику стандартного CsrfViewMiddleware таким образом, чтобы он проверял тип GraphQL запроса, и уже на основе этого принимал или сбрасывал соединение.\nДля этого добавим кастомную проверку CSRF, например, в уже знакомый нам файл api.py\napi.py # backend/backend/api.py import json import graphene from django.middleware.csrf import CsrfViewMiddleware from backend.todo_list.schema import Query, Mutation schema = graphene.Schema(query=Query, mutation=Mutation) class CustomCsrfMiddleware(CsrfViewMiddleware): def process_view(self, request, callback, callback_args, callback_kwargs): if getattr(request, \u0026#39;csrf_processing_done\u0026#39;, False): return None if getattr(callback, \u0026#39;csrf_exempt\u0026#39;, False): return None try: body = request.body.decode(\u0026#39;utf-8\u0026#39;) body = json.loads(body) # в любой непонятной ситуации передаём запрос оригинальному CsrfViewMiddleware except (TypeError, ValueError, UnicodeDecodeError): return super(CustomCsrfMiddleware, self).process_view(request, callback, callback_args, callback_kwargs) # проверка на list, т.к. клиент может отправлять \u0026#34;батченные\u0026#34; запросы # https://blog.apollographql.com/batching-client-graphql-queries-a685f5bcd41b if isinstance(body, list): for query in body: # если внутри есть хотя бы одна мутация, то отправляем запрос # к оригинальному CsrfViewMiddleware if \u0026#39;mutation\u0026#39; in query: break else: return self._accept(request) else: # принимаем любые query без проверки на csrf if \u0026#39;query\u0026#39; in body and \u0026#39;mutation\u0026#39; not in body: return self._accept(request) return super(CustomCsrfMiddleware, self).process_view(request, callback, callback_args, callback_kwargs) Далее, в файле settings.py нужно заменить \u0026ldquo;оригинальный\u0026rdquo; CsrfViewMiddleware, на кастомный:\n# settings.py MIDDLEWARE = [ ..., \u0026#39;backend.backend.api.CustomCsrfMiddleware\u0026#39;, # \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, ..., ] Если уважаемый читатель знает более надежные и правильные способы CSRF-защиты в связке Django + Nuxt + Apollo, то призываю поделиться своим знанием в комментариях.\nDjango CORS Headers Т.к. dev сервера бэкенда и фронтента у нас стоят на разных портах, то Django нужно оповестить, с каких хостов могут совершаться запросы, и какие заголовки ему разрешено обрабатывать. А поможет нам в этом библиотека django-cors-headers:\npipenv install \u0026#34;django-cors-headers\u0026gt;=3.2\u0026#34; В settings.py добавим:\n# backend/backend/settings.py from corsheaders.defaults import default_headers INSTALLED_APPS = [ ..., \u0026#39;graphene_django\u0026#39;, \u0026#39;backend.todo_list\u0026#39;, \u0026#39;corsheaders\u0026#39;, # вот эту строку ] CORS_ALLOW_CREDENTIALS = True CORS_ALLOW_HEADERS = default_headers + (\u0026#39;cache-control\u0026#39;, \u0026#39;cookies\u0026#39;) CORS_ORIGIN_ALLOW_ALL = True # не рекомендуется для production # А также парочку middleware MIDDLEWARE = [ ..., \u0026#39;corsheaders.middleware.CorsMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, ..., ] Установка и настройка Apollo Для Nuxt существует собственный модуль apollo, который в свою очередь основан на библиотеке vue-apollo (которая в свою очередь основана на Apollo). Для его установки введите:\nnpm install --save @nuxtjs/apollo graphql-tag cookie-universal-nuxt Также при конфигурации Apollo нам понадобится небольшая библиотека cookie-universal-nuxt для манипуляции куками при рендере на стороне сервера. Добавим эти модули в nuxt.config.js. В зависимости от вашей изначальной конфигурации там уже может быть несоклько модулей. Как минимум там должен быть vuetify:\n// nuxt.config.js export default { ..., modules: [ ..., \u0026#39;@nuxtjs/vuetify\u0026#39;, \u0026#39;@nuxtjs/apollo\u0026#39;, \u0026#39;cookie-universal-nuxt\u0026#39; ], apollo: { clientConfigs: { default: \u0026#39;~/plugins/apollo-client.js\u0026#39; } }, ... } Настройка Apollo дело невсегда тривиальное. Постараемся обойтись минимальной конфигурацией. Создадим файл по указанному выше пути:\nКонфигурируем клиент Apollo, а вместе с тем формируем цепочку обработчиков запросов.\napollo-client.js // frontend/plugins/apollo-client.js import { HttpLink } from \u0026#39;apollo-link-http\u0026#39; import { setContext } from \u0026#39;apollo-link-context\u0026#39; import { from, concat } from \u0026#39;apollo-link\u0026#39; import { InMemoryCache } from \u0026#39;apollo-cache-inmemory\u0026#39; // Если плагин является функцией, то в процессе инициализации Nuxt передаёт в неё контекст ctx export default ctx =\u0026gt; { /** * По-умолчанию при рендере со стороны сервера заголовки * в запросе к бэкенду не отправляются, так что \u0026#34;пробрасываем\u0026#34; * заголовки от клиента. */ const ssrMiddleware = setContext((_, { headers }) =\u0026gt; { if (process.client) return headers return { headers: { ...headers, connection: ctx.app.context.req.headers.connection, referer: ctx.app.context.req.headers.referer, cookie: ctx.app.context.req.headers.cookie } } }) /** * Добавление CSRF-токена к запросу. * https://docs.djangoproject.com/en/2.2/ref/csrf/#ajax */ const csrfMiddleware = setContext((_, { headers }) =\u0026gt; { return { headers: { ...headers, \u0026#39;X-CSRFToken\u0026#39;: ctx.app.$cookies.get(\u0026#39;csrftoken\u0026#39;) || null } } }) const httpLink = new HttpLink({ uri: \u0026#39;http://localhost:8000/graphql/\u0026#39;, credentials: \u0026#39;include\u0026#39; }) // Middleware в Apollo это примерно тоже самое что и middleware в Django, // только на стороне клиента. Объединяем их в цепочку. Последовательность важна. const link = from([csrfMiddleware, ssrMiddleware, httpLink]) // Инициализируем кэш. При должном усердии он может заменить Vuex, // но об этом как-нибудь в другой раз const cache = new InMemoryCache() return { link, cache, // без отключения стандартного apollo-module HttpLink\u0026#39;a в консоль сыпятся варнинги defaultHttpLink: false } } На этом этапе лучше еще раз удостовериться, что Nuxt собирается без ошибок, запустив dev сервер.\nОживляем приложение И вот наконец настало время соединить фронт и бэк.\nДля начала где-нибудь создадим файл, в котором будут храниться все запросы и мутации к бэкенду. В моем случае этот файл расположился по пути frontend/graphql.js с уже знакомым нам содержимым:\ngraphql.js import gql from \u0026#39;graphql-tag\u0026#39; // т.к. внутренности записи Todo используются практически во всех запросах, // то резонно вынести их в отдельный фрагмент // https://www.apollographql.com/docs/react/data/fragments/ const TODO_FRAGMENT = gql` fragment TodoContents on TodoNode { id title text done createdDate dueDate category { id name } } ` const ADD_TODO = gql` mutation( $title: String! $text: String $dueDate: Date! $category: String! ) { addTodo( title: $title text: $text dueDate: $dueDate category: $category ) { ...TodoContents } } ${TODO_FRAGMENT} ` const TOGGLE_TODO = gql` mutation($todoId: ID) { toggleTodo(todoId: $todoId) { ...TodoContents } } ${TODO_FRAGMENT} ` const GET_CATEGORIES = gql` { categories { id name } } ` const GET_TODO_LIST = gql` { todoList { ...TodoContents } } ${TODO_FRAGMENT} ` const REMOVE_TODO = gql` mutation($todoId: ID) { removeTodo(todoId: $todoId) } ` export { ADD_TODO, TOGGLE_TODO, GET_CATEGORIES, GET_TODO_LIST, REMOVE_TODO } Теперь нужно немного изменить уже существующий функционал фронтенда. Наконец пришло время добавить туда взаимодействие с бэкендом.\nИзменим Vue компоненты:\nindex.vue \u0026lt;!-- frontend/pages/index.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;v-layout row wrap justify-center\u0026gt; \u0026lt;v-flex xs8 class=\u0026#34;pb-1\u0026#34;\u0026gt; \u0026lt;!-- emit\u0026#39;ы теперь нам не нужны --\u0026gt; \u0026lt;new-todo-form /\u0026gt; \u0026lt;/v-flex\u0026gt; \u0026lt;v-flex v-for=\u0026#34;todo of todoList\u0026#34; :key=\u0026#34;todo.id\u0026#34; xs8 class=\u0026#34;my-1\u0026#34;\u0026gt; \u0026lt;todo-item :todo=\u0026#34;todo\u0026#34; /\u0026gt; \u0026lt;/v-flex\u0026gt; \u0026lt;/v-layout\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import NewTodoForm from \u0026#39;../components/NewTodoForm\u0026#39; import TodoItem from \u0026#39;../components/TodoItem\u0026#39; // импортируем свеженаписанные запросы import { GET_TODO_LIST } from \u0026#39;../graphql\u0026#39; export default { components: { TodoItem, NewTodoForm }, data() { return { todoList: [] } }, apollo: { // получаем список todoList. При таком объявлении запроса переменная todoList // должна записаться результатами запроса, однако запрос должен называться // аналогично с переменной todoList: { query: GET_TODO_LIST } } } \u0026lt;/script\u0026gt; NewTodoForm.vue \u0026lt;!-- frontend/components/NewTodoForm.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;v-card\u0026gt; \u0026lt;v-card-title class=\u0026#34;pb-1\u0026#34; style=\u0026#34;overflow-wrap: break-word;\u0026#34;\u0026gt; \u0026lt;b\u0026gt;{{ todo.title }}\u0026lt;/b\u0026gt; \u0026lt;v-spacer /\u0026gt; \u0026lt;!-- Изменено событие --\u0026gt; \u0026lt;v-btn @click=\u0026#34;remove\u0026#34; flat small icon style=\u0026#34;position: absolute; right: 0; top: 0\u0026#34; \u0026gt; \u0026lt;v-icon :disabled=\u0026#34;$nuxt.isServer\u0026#34; small\u0026gt;close\u0026lt;/v-icon\u0026gt; \u0026lt;/v-btn\u0026gt; \u0026lt;/v-card-title\u0026gt; \u0026lt;v-card-text class=\u0026#34;py-1\u0026#34;\u0026gt; \u0026lt;v-layout row justyfy-center align-center\u0026gt; \u0026lt;v-flex xs11 style=\u0026#34;overflow-wrap: break-word;\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/v-flex\u0026gt; \u0026lt;v-flex xs1\u0026gt; \u0026lt;div style=\u0026#34;text-align: right;\u0026#34;\u0026gt; \u0026lt;!-- Добавлена обработка клика --\u0026gt; \u0026lt;v-checkbox :value=\u0026#34;todo.done\u0026#34; @click.once=\u0026#34;toggle\u0026#34; hide-details class=\u0026#34;pa-0 ma-0\u0026#34; style=\u0026#34;display: inline-block;\u0026#34; color=\u0026#34;green lighten-1\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/v-flex\u0026gt; \u0026lt;/v-layout\u0026gt; \u0026lt;/v-card-text\u0026gt; \u0026lt;v-card-actions\u0026gt; \u0026lt;span class=\u0026#34;grey--text\u0026#34;\u0026gt; Выполнить до \u0026lt;v-icon small\u0026gt;event\u0026lt;/v-icon\u0026gt; {{ todo.dueDate }} | Создано \u0026lt;v-icon small\u0026gt;calendar_today\u0026lt;/v-icon\u0026gt; {{ todo.createdDate }} \u0026lt;/span\u0026gt; \u0026lt;v-spacer /\u0026gt; \u0026lt;span class=\u0026#34;grey--text\u0026#34;\u0026gt; \u0026lt;!-- Изменен путь получения имени категории --\u0026gt; \u0026lt;v-icon small\u0026gt;category\u0026lt;/v-icon\u0026gt;Категория: {{ todo.category.name }} \u0026lt;/span\u0026gt; \u0026lt;/v-card-actions\u0026gt; \u0026lt;/v-card\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // импортируем свеженаписанные запросы import { GET_TODO_LIST, REMOVE_TODO, TOGGLE_TODO } from \u0026#39;../graphql\u0026#39; export default { name: \u0026#39;TodoItem\u0026#39;, props: { todo: { type: Object, default: () =\u0026gt; ({}) } }, // с этого момента изменения по-серьезнее methods: { toggle() { // Для запроса который возвращает измененный элемент не обязательно // вручную прописывать функцию update. Apollo сам найдёт в каких // запросах \u0026#34;участвует\u0026#34; измененная запись, и разошлет всем подписчикам // измененный объект. В нашем случае это запрос в компоненте index.vue // на получение списка Todo this.$apollo.mutate({ mutation: TOGGLE_TODO, variables: { todoId: this.todo.id } }) }, remove() { // функция update не видит контекста this const todoId = this.todo.id this.$apollo.mutate({ mutation: REMOVE_TODO, variables: { todoId }, update(store, { data: { removeTodo } }) { if (!removeTodo) return // В случае успешного удаления удаляем текущий элемент из кэша const data = store.readQuery({ query: GET_TODO_LIST }) data.todoList = data.todoList.filter(todo =\u0026gt; todo.id !== todoId) // Самоуничтожаемся! store.writeQuery({ query: GET_TODO_LIST, data }) } }) } } } \u0026lt;/script\u0026gt; TodoItem.vue \u0026lt;!-- frontend/components/TodoItem.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;v-card\u0026gt; \u0026lt;v-card-title class=\u0026#34;pb-1\u0026#34; style=\u0026#34;overflow-wrap: break-word;\u0026#34;\u0026gt; \u0026lt;b\u0026gt;{{ todo.title }}\u0026lt;/b\u0026gt; \u0026lt;v-spacer /\u0026gt; \u0026lt;!-- Изменено событие --\u0026gt; \u0026lt;v-btn @click=\u0026#34;remove\u0026#34; flat small icon style=\u0026#34;position: absolute; right: 0; top: 0\u0026#34; \u0026gt; \u0026lt;v-icon :disabled=\u0026#34;$nuxt.isServer\u0026#34; small\u0026gt;close\u0026lt;/v-icon\u0026gt; \u0026lt;/v-btn\u0026gt; \u0026lt;/v-card-title\u0026gt; \u0026lt;v-card-text class=\u0026#34;py-1\u0026#34;\u0026gt; \u0026lt;v-layout row justyfy-center align-center\u0026gt; \u0026lt;v-flex xs11 style=\u0026#34;overflow-wrap: break-word;\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/v-flex\u0026gt; \u0026lt;v-flex xs1\u0026gt; \u0026lt;div style=\u0026#34;text-align: right;\u0026#34;\u0026gt; \u0026lt;!-- Добавлена обработка клика --\u0026gt; \u0026lt;v-checkbox :value=\u0026#34;todo.done\u0026#34; @click.once=\u0026#34;toggle\u0026#34; hide-details class=\u0026#34;pa-0 ma-0\u0026#34; style=\u0026#34;display: inline-block;\u0026#34; color=\u0026#34;green lighten-1\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/v-flex\u0026gt; \u0026lt;/v-layout\u0026gt; \u0026lt;/v-card-text\u0026gt; \u0026lt;v-card-actions\u0026gt; \u0026lt;span class=\u0026#34;grey--text\u0026#34;\u0026gt; Выполнить до \u0026lt;v-icon small\u0026gt;event\u0026lt;/v-icon\u0026gt; {{ todo.dueDate }} | Создано \u0026lt;v-icon small\u0026gt;calendar_today\u0026lt;/v-icon\u0026gt; {{ todo.createdDate }} \u0026lt;/span\u0026gt; \u0026lt;v-spacer /\u0026gt; \u0026lt;span class=\u0026#34;grey--text\u0026#34;\u0026gt; \u0026lt;!-- Изменен путь получения имени категории --\u0026gt; \u0026lt;v-icon small\u0026gt;category\u0026lt;/v-icon\u0026gt;Категория: {{ todo.category.name }} \u0026lt;/span\u0026gt; \u0026lt;/v-card-actions\u0026gt; \u0026lt;/v-card\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // импортируем свеженаписанные запросы import { GET_TODO_LIST, REMOVE_TODO, TOGGLE_TODO } from \u0026#39;../graphql\u0026#39; export default { name: \u0026#39;TodoItem\u0026#39;, props: { todo: { type: Object, default: () =\u0026gt; ({}) } }, // с этого момента изменения по-серьезнее methods: { toggle() { // Для запроса который возвращает измененный элемент не обязательно // вручную прописывать функцию update. Apollo сам найдёт в каких // запросах \u0026#34;участвует\u0026#34; измененная запись, и разошлет всем подписчикам // измененный объект. В нашем случае это запрос в компоненте index.vue // на получение списка Todo this.$apollo.mutate({ mutation: TOGGLE_TODO, variables: { todoId: this.todo.id } }) }, remove() { // функция update не видит контекста this const todoId = this.todo.id this.$apollo.mutate({ mutation: REMOVE_TODO, variables: { todoId }, update(store, { data: { removeTodo } }) { if (!removeTodo) return // В случае успешного удаления удаляем текущий элемент из кэша const data = store.readQuery({ query: GET_TODO_LIST }) data.todoList = data.todoList.filter(todo =\u0026gt; todo.id !== todoId) // Самоуничтожаемся! store.writeQuery({ query: GET_TODO_LIST, data }) } }) } } } \u0026lt;/script\u0026gt; Проверим, что у нас получилось\nРезультат Заключение В этой статье я попытался рассказать как построить взаимодействие между Django и Nuxt с помощью GraphQL API, показать решение проблем с которыми довелось столкнуться мне. Надеюсь это подтолкнет энтузиастов попробовать что-то новое, и сэкономит время в решении проблем.\nВесь код доступен на GitHub.\n","date":"2020-03-16T00:00:00Z","image":"https://ingvarlistard.github.io/p/nuxt-django-graphql/cmnlwmcwqu2drhdusjqe2nn6luq_hudde38cee2deb85aef79833b7aa1c1180_25654_120x120_fill_q75_box_smart1.jpeg","permalink":"https://ingvarlistard.github.io/p/nuxt-django-graphql/","title":"Nuxt + Django + GraphQL на примере"}]